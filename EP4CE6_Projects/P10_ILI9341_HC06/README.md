# Interfacing an FPGA with an ILI9341 TFT module and HC06 Bluetooth Module        
## Description  
In this project, the FPGA decodes commands received from an HC06 Bluetooth module to determine the colour  
that should be displayed on the ILI9341 module. There are four colours that can be displayed on the TFT  
screen. These are: red, green, blue, and white.   
- When ``R`` or ``r`` is received, the screen will be filled with red.    
- When ``G`` or ``g`` is received, the screen will be filled with green.   
- When ``B`` or ``b`` is received, the screen will be filled with blue.   
- When characters other than the aforementioned ones are received, the screen will be filled with white.   

System specs:     
- 50 MHz main clock     
-  2 MHz: PLL clock    
-  1 MHz: SPI clock for the ILI9341      
- 9600 baud rate for the HC06    

## Tools  
- EP4CE6E22C8N Cyclone IV FPGA development board
- ILI9341 TFT Display Module (2.4 inches, 240 x 320)    
- HC06 Bluetooth Module     
- Intel Quartus Prime 20.1
- ModelSim (for simulation)  

## Project file structure     
- The VHDL design files are located in the ``src`` and ``lib`` directories  
- The top-level design is the ``rgb_display.vhd``  
- The other modules or design files are located in the ``lib`` directory
- Testbenches are located in the ``simulation/testbench`` directory
- Test vectors for each module in the design can be found in the directories within the ``simulation/file/`` directory.  
- Test vectors are generated by the python scripts in the ``simulation/python_scripts/`` directory  
```
.
├── README.md
├── rgb_display.tcl
├── simulation
│   ├── enc.do
│   ├── main.do
│   ├── python_scripts
│   │   ├── enc_testvectors.py
│   │   ├── main_testvectors.py
│   │   ├── spi_testvectors.py
│   │   └── uart_testvectors.py
│   ├── spi.do
│   ├── testbench
│   │   ├── encoder_tb.vhd
│   │   ├── pack_tb_body.vhd
│   │   ├── pack_tb_header.vhd
│   │   ├── rgb_display_tb.vhd
│   │   ├── spi_tx_tb.vhd
│   │   └── uart_rx_tb.vhd
│   └── uart.do
└── src
    ├── lib
    │   ├── encoder.vhd
    │   ├── pll
    │   │   ├── pll.ppf
    │   │   ├── pll.qip
    │   │   └── pll.vhd
    │   ├── spi_tx.vhd
    │   └── uart_rx.vhd
    └── rgb_display.vhd
```

## Building the project from a TCL script  
Ensure you're in the ``EP4CE6_Projects/P10_ILI9341_HC06/`` directory before running the commands below.  
```
1. mkdir build  
2. cd build
3. quartus_sh -t ../rgb_display.tcl
4. quartus rgb_display.qpf
```

## What to do when Quartus opens    
- After Quartus opens, click on the ``Processing`` tab  
- Click on ``Start Compilation``  
- After compilation, click on ``Program Device(Open Programmer)``  
- When the Programmer window opens, load the demo project into the FPGA by clicking ``Start``

## Pinouts  
- Check the ``Location`` column in the image below for the pin mappings used in this project.      
![Screenshot (527)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/6c0cce9a-9c37-49e1-9f8b-279e9a46faed)  

## Decoding SPI (ILI9341) and UART (HC06) with a Logic Analyzer        
### 1. Configuring the registers of the ILI9341 using data/command sent via SPI from the FPGA     
![Screenshot (528)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/0282292f-eb6c-4044-9875-005c0e704c82)   
![Screenshot (529)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/549daa4c-344e-4ed1-b3dc-109f7c86737c)    
### 2. FPGA receives UART command (``R``) and sends pixel data (Red) to the ILI9341 via SPI   
![Screenshot (530)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/895cb303-5fae-438e-8b9e-c1635fcc4015)   
![Screenshot (531)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/0c286f7f-25bb-4f35-9ee9-a1aca96e0abe)    

## Demo         
[Video Demo](https://drive.google.com/file/d/1j0V4eVPRZ2ItI5fE4JJh-jrtvqcAinYw/view?usp=sharing)   

## Helpful resources   
- [ILITEK ILI9341 Specifications Document](https://drive.google.com/file/d/1omF5Pk9mfnfzifMGQ6iuK6_T9_BTqp32/view?usp=sharing)
- FPGA Prototyping By VHDL Examples (Xilinx Spartan-3 Version) - Pong P. Chu (Check timing diagrams for UART)   
- [Altera: Quartus II Handbook, Volume 3. Verification](https://drive.google.com/file/d/1oJjXx_n8-xdQk2OVQpPyZaf3n0bG2LTP/view?usp=sharing) - A very helpful document from Altera that allowed me to simulate this project in ModelSim. I wasn't able to simulate the top level design initially because of the Altera PLL IP. After searching online (forums) and discovering this document, I was able to compile the top level design (with an instantiated PLL IP) in ModelSim and run the simulation for it. In order to compile and simulate designs that use Altera IP cores, kindly check ``Chapter 1: Mentor Graphics, ModelSim Support, Simulating VHDL Designs. Pg 1-5``.

## Simulating the project with Modelsim  
Ensure you're in the ``EP4CE6_Projects/P10_ILI9341_HC06/simulation/`` directory before proceeding to the next steps.  
The ``.do`` macro files are scripts that contain commands ModelSim uses to compile design files and testbenches. These scripts automate the simulation process by preventing the need to open the ModelSim GUI. For projects with multiple ``.do`` files, the process of executing one script is applicable to the rest. Therefore, the simulation procedure for one script is shown below.  

Procedure for the ``enc.do`` script (Same for the other scripts).  
```
mkdir build
cd build
vsim -c -do "do ../enc.do; quit"
```
Do not panic if the following output shows up on the command line: ``# ** Failure: Simulation done``. This is a VHDL quirk. However, you need to ensure no test fails. Simulation results can be found in the ``status_reports.txt`` files generated by the Python scripts invoked by ModelSim. Refer to the tree diagram in the [Project file structure](#project-file-structure) section of this README document.   

You need to create an environment variable to store the Quartus installation root in order to avoid the following error: "ERROR: quartus_root not set and MY_QUARTUS_PATH environment variable not found." The steps required to achieve this are explained below.  

For Linux (Ubuntu) users:  
Open the `.bashrc` file and add the following lines.   
```
export MY_QUARTUS_PATH="/opt/intelFPGA_lite/20.1/quartus"
export PATH="$MY_QUARTUS_PATH/bin:$PATH"
```
Run `source ~/.bashrc` and restart your terminal.   

## Recommendation(s)/Area(s) of improvement   
At the time of creating this project, I wanted to experiment with concurrent statements a bit more. After successfully testing and running this design, I realized the `spi_tx.vhd` could use some work as far as readability and simplicity go. I could have expressed some parts of the design with **processes** instead of overusing the concurrent statements with nested combinational logic. Furthermore, the naming convention can be made more intuitive. The SPI finite state machine (FSM) can be made more modular by separating the logic for initializing the ILI9341 hardware from the logic that writes pixel data to it. A snippet of `spi_tx.vhd` design that can be improved is shown below.   

**Processes/sequential statements would be easier to read.**  
```
   -- Counters
   cnt1_next <= cnt1_reg + 1 when (state = ST_TFT_RST and cnt1_reg /= CNT_RST)
                               or (state = ST_5MS and cnt1_reg /= CNT_1MS)
                               or (state = ST_120MS and cnt1_reg /= CNT_1MS)
                               
        else        0        when (state = ST_TFT_RST and cnt1_reg = CNT_RST)
                               or (state = ST_5MS and cnt1_reg = CNT_1MS)
                               or (state = ST_120MS and cnt1_reg = CNT_1MS)                         
        else    cnt1_reg;
   
   cnt2_next <= cnt2_reg + 1 when (state = ST_5MS and cnt1_reg = CNT_1MS
                                   and cnt2_reg /= CNT_005) 
                               or (state = ST_120MS and cnt1_reg = CNT_1MS
                                   and cnt2_reg /= CNT_120)
                               
        else        0        when (state = ST_5MS and cnt1_reg = CNT_1MS
                                   and cnt2_reg = CNT_005)
                               or (state = ST_120MS and cnt1_reg = CNT_1MS
                                   and cnt2_reg = CNT_120)
        else    cnt2_reg;
   
   index_next <= index_reg - 1 when dc_mode = '1' and sck2_reg = '1' 
                                and index_reg > 0
                               
         else        7         when dc_mode = '1' and sck2_reg = '1'
                                and index_reg = 0
         else    index_reg;
   
   cnt3_next <= cnt3_reg + 1 when state = ST_SEND_PIXELS and sck2_reg = '1'
                              and index_reg = 0 and cnt3_reg /= CNT_BYTES
         
         else       0        when state = ST_SEND_PIXELS and sck2_reg = '1'
                              and index_reg = 0 and cnt3_reg = CNT_BYTES
         else   cnt3_reg;
   
   cnt4_next <= cnt4_reg + 1 when state = ST_SEND_PIXELS and sck2_reg = '1'
                              and index_reg = 0 and cnt3_reg = CNT_BYTES
                              and cnt4_reg /= CNT_006
                              
        else        0        when state = ST_SEND_PIXELS and sck2_reg = '1' 
                              and index_reg = 0 and cnt3_reg = CNT_BYTES 
                              and cnt4_reg = CNT_006
        else    cnt4_reg;
```

