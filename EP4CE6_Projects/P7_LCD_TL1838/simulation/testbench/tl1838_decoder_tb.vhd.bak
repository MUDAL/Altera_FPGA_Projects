library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use STD.TEXTIO.ALL;
use IEEE.STD_LOGIC_TEXTIO.ALL;
library work;

entity tl1838_decoder_tb is
end tl1838_decoder_tb;

architecture tl1838_decoder_behav of tl1838_decoder_tb is
   -- Constants
   constant CLK_PERIOD: time := 20 ns;
   -- Delay before injecting next stimulus to the UUT
   constant COMMS_INTERVAL: time := 10 * CLK_PERIOD;
   -- Signals
   signal rst_n: std_logic;
   signal clk: std_logic := '0';
   signal ir: std_logic; -- IR decoder's input
   signal data_out: std_logic_vector(31 downto 0);
   signal done: std_logic;
   -- Function (character to std_logic_vector(slv))
   function char2slv(char: character) return std_logic_vector is
      variable slv: std_logic_vector(3 downto 0);
   begin
      case char is
         -- 0 to 9
         when '0' => slv := "0000";
         when '1' => slv := "0001";
         when '2' => slv := "0010";
         when '3' => slv := "0011";
         when '4' => slv := "0100";
         when '5' => slv := "0101";
         when '6' => slv := "0110";
         when '7' => slv := "0111";
         when '8' => slv := "1000";
         when '9' => slv := "1001";
         -- A to F
         when 'A' | 'a' => slv := "1010";
         when 'B' | 'b' => slv := "1011";
         when 'C' | 'c' => slv := "1100";
         when 'D' | 'd' => slv := "1101";
         when 'E' | 'e' => slv := "1110";
         when 'F' | 'f' => slv := "1111";
         -- Non-Hex (Don't care)
         when others =>
      end case;
      return slv;
   end function;
begin
   uut: entity work.tl1838_decoder(tl1838_decoder_rtl)
   port map(rst_n => rst_n, clk => clk, ir => ir,
            data_out => data_out, done => done);
   
   reset: rst_n <= '0', '1' after 2 * CLK_PERIOD;
   
   clock_generation: process
   begin
      wait for CLK_PERIOD / 2;
      clk <= not clk;
   end process;
   
   stimuli: process
      file testcases: text;   
      variable testcase: line;
      variable keycode: string(1 to 8); -- String indexes start from 1
      variable ir_tx: std_logic_vector(31 downto 0); -- TL1838's output
      -- Constants for NEC protocol timing
      constant NEC_START_HIGH: time := 450_000 * CLK_PERIOD; -- 9 ms 
      constant NEC_START_LOW: time := NEC_START_HIGH / 2; -- 4.5 ms
      constant NEC_HIGH_PULSE: time := 28110 * CLK_PERIOD; -- 562.2 uS
      constant NEC_LOW_PULSE_0: time := NEC_HIGH_PULSE;     
      constant NEC_LOW_PULSE_1: time := 84350 * CLK_PERIOD; -- 1.687 ms
   begin
      -- Read test inputs (keycodes) from the file with the testcases. 
      file_open(testcases,"file/ir/testcases.txt",read_mode);
      while not endfile(testcases) loop
         readline(testcases,testcase);
         read(testcase,keycode);
         
         -- Convert test inputs (keycodes) to the binary form of the 
         -- actual signals to be transmitted by the IR detector (TL1838). 
         ir_tx(31 downto 28) := char2slv(keycode(1));
         ir_tx(27 downto 24) := char2slv(keycode(2));        
         ir_tx(23 downto 20) := char2slv(keycode(3));
         ir_tx(19 downto 16) := char2slv(keycode(4));
         ir_tx(15 downto 12) := char2slv(keycode(5));
         ir_tx(11 downto 8)  := char2slv(keycode(6));
         ir_tx(7 downto  4)  := char2slv(keycode(7));
         ir_tx(3 downto  0)  := char2slv(keycode(8));
         
         -- Simulate transmission of IR detector's output signal to the  
         -- IR decoder module (FPGA). Timing signals are generated here.
         -- The NEC protocol is implemented here:
         -- 0. 9 ms high pulse, then 4.5 ms low pulse (before actual data)
         -- 1. Logic '1' = 562.2 uS high pulse followed by 1.687 ms low pulse
         -- 2. Logic '0' = 562.2 uS high pulse followed by 562.2 uS low pulse
         -- 3. LSB is transmitted first
         
         -- Initial signals from the IR detector before real data arrives
         ir <= '1';
         wait for NEC_START_HIGH;
         ir <= '0';
         wait for NEC_START_LOW;
         
         -- Arrival of real data to be decoded
         for idx in 0 to 31 loop
            if ir_tx(idx) = '0' then
               ir <= '1';
               wait for NEC_HIGH_PULSE;
               ir <= '0';
               wait for NEC_LOW_PULSE_0;
            else
               ir <= '1';
               wait for NEC_HIGH_PULSE;
               ir <= '0';
               wait for NEC_LOW_PULSE_1;
            end if;
         end loop;
         
         -- End of data transmission from IR detector to IR decoder
         ir <= '1';
         wait for NEC_HIGH_PULSE;
         ir <= '0';
         
         wait until done = '1';
         wait until done = '0';
         wait for COMMS_INTERVAL;         
      end loop;
      file_close(testcases);
      wait;
   end process;
   
   output_verification: process
      file expected_outputs: text; 
      file status_reports: text;       
      variable expected_output: line;
      variable status_report: line;
      variable keycode: string(1 to 8);
      -- Expected IR decoder output in std_logic_vector form
      variable decoder_out: std_logic_vector(31 downto 0); 
      variable status: string(1 to 4);
      variable msg: string(1 to 100);
   begin
      -- Read expected outputs (keycodes) 
      file_open(expected_outputs,"file/ir/expected_outputs.txt",read_mode);
      -- Store test results
      file_open(status_reports,"file/ir/status_reports.txt",write_mode);
      while not endfile(expected_outputs) loop
         readline(expected_outputs,expected_output);
         read(expected_output,keycode);
         
         -- Convert expected outputs (keycodes) to binary form to enable 
         -- comparison with data output from UUT (IR decoder module)
         decoder_out(31 downto 28) := char2slv(keycode(1));
         decoder_out(27 downto 24) := char2slv(keycode(2));        
         decoder_out(23 downto 20) := char2slv(keycode(3));
         decoder_out(19 downto 16) := char2slv(keycode(4));
         decoder_out(15 downto 12) := char2slv(keycode(5));
         decoder_out(11 downto 8)  := char2slv(keycode(6));
         decoder_out(7 downto  4)  := char2slv(keycode(7));
         decoder_out(3 downto  0)  := char2slv(keycode(8));
         
         wait until done = '1';
         
         if data_out = decoder_out then
            status := "PASS";
         else
            status := "FAIL";
         end if;        
         
         msg := "Expected: " & 
                integer'image(to_integer(unsigned(decoder_out))) & ", " &
                "Got: " &
                integer'image(to_integer(unsigned(data_out))) & ", " &
                "Status: " & status;
         report msg; -- Result of testcase
         write(status_report,msg);
         writeline(status_reports,status_report);
         
         wait until done = '0';
      end loop;
      file_close(expected_outputs);
      file_close(status_reports);
      wait;
   end process;
   
   dummy: process
      file status_reports: text;       
      variable status_report: line; 
      variable status: string(1 to 4) := "PASS";
      variable msg: string(1 to 100) := "RJX";  
      variable a: std_logic_vector(3 downto 0) := "0011";
   begin
      file_open(status_reports,"file/ir/status_reports.txt",write_mode);
--      msg := "Expected: " & 
--             integer'image(to_integer(unsigned(a))) & ", " &
--             "Got: " &
--             integer'image(to_integer(unsigned(a))) & ", " &
--             "Status: " & status;
      report msg; -- Result of testcase
      write(status_report,msg);
      writeline(status_reports,status_report);
      file_close(status_reports);
      wait;
   end process;
   
end tl1838_decoder_behav;


