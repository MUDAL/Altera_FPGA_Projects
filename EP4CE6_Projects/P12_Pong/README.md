# PONG
![20240716_162535](https://github.com/user-attachments/assets/9ee192a8-05d6-4030-ab9e-0dee5d5aeabc)  

## Description    
This project implements a classic Pong game with an Altera EP4CE6E22C8N Cyclone IV FPGA board, its tactile buttons and buzzer, and a VGA monitor. The game is designed to be single-player i.e. the player plays against an autonomously controlled opposition.  

In the Pong game, there are two paddles and a ball. The player controls the left paddle using two buttons on the FPGA board. One button enables upward movements, while the other moves the paddle in a downward direction. The right paddle is autonomously controlled by digital logic circuits. The reaction time of the right paddle is adjusted every time the left paddle hits the ball. The changes in the right paddle's response prevent it from being unbeatable. The onboard buzzer generates a 3 kHz sound for a short duration every time the ball collides with the following game elements:
1. Left paddle  
2. Right paddle  
3. Upper border of the game board (or screen)  
4. Lower border of the game board (or screen)  

The fonts for the scoreboard's digits are implemented using combinational logic (priority muxes and asynchronous ROMs). Another way to implement them is to use the FPGA's block RAMs (this should give better timing results). I wrote some python scripts to generate VHDL code for the Font ROMs by drawing the desired characters (to be displayed on the VGA monitor) using a simple Tkinter interface.  

The "game menu" and "game over" bitmaps (with respective texts of ``PONG`` and ``GAME OVER``) were generated from a simple MATLAB script that performs thresholding and colour inversion on JPEG files (images containing the ``PONG`` and ``GAME OVER`` texts). The MATLAB script also converts the bitmap images to Memory Initialization Files (.mif) whose contents are loaded into the FPGA's block RAMs at compilation time.  

The design is fully constrained and it successfully meets all timing requirements (target frequency of 50 MHz, setup and hold time requirements, etc). The constraints file (pong_main.sdc) can be found in the ``EP4CE6_Projects/P12_Pong/VHDL/`` directory.  

For additional information, kindly check the ``README.md`` in the ``MATLAB`` and ``Python`` directories.  

## Tools  
- EP4CE6E22C8N Cyclone IV FPGA development board  
- VGA monitor (640 x 480)  
- VGA cable  
- Intel Quartus Prime 20.1  
- ModelSim (for simulation)  

## Project file structure (RTL) 
- The ``VHDL`` design files are located in the ``src`` and ``lib`` directories  
- The top-level design is the ``pong_main.vhd``  
- The other modules or design files are located in the ``lib`` directory  
- The ``mif`` directory contains the ``Memory Initialization Files (.mif)`` generated by MATLAB  
```
.
├── MATLAB
│   ├── gamemenu_inverted.jpg
│   ├── game_menu.jpg
│   ├── game_menu.mif
│   ├── gameover_inverted.jpg
│   ├── game_over.jpg
│   ├── game_over.mif
│   ├── img_to_mif.m
│   ├── main.m
│   └── README.md
├── Python
│   ├── font_rom_gen_1.py
│   ├── font_rom_gen_2.py
│   └── README.md
├── README.md
├── Version_1
│   └── VHDL
│       ├── constraints
│       │   └── pong_main.sdc
│       ├── pong_main.tcl
│       ├── simulation
│       │   ├── button_logic.do
│       │   ├── score_logic.do
│       │   └── testbench
│       │       ├── button_logic_tb.vhd
│       │       ├── pack_tb_body.vhd
│       │       ├── pack_tb_header.vhd
│       │       └── score_logic_tb.vhd
│       └── src
│           ├── lib
│           │   ├── auto_control.vhd
│           │   ├── ball_logic.vhd
│           │   ├── bitmap_generator.vhd
│           │   ├── bitmap_memory.vhd
│           │   ├── button_logic.vhd
│           │   ├── collision_logic.vhd
│           │   ├── counter.vhd
│           │   ├── font_logic.vhd
│           │   ├── game_board.vhd
│           │   ├── game_config.vhd
│           │   ├── paddle_logic.vhd
│           │   ├── pkg.vhd
│           │   ├── score_logic.vhd
│           │   ├── sound.vhd
│           │   ├── vga_graphics.vhd
│           │   └── vga_sync.vhd
│           ├── mif
│           │   ├── game_menu.mif
│           │   └── game_over.mif
│           └── pong_main.vhd
└── Version_2
    └── VHDL
        ├── constraints
        │   └── pong_main.sdc
        ├── pong_main.tcl
        ├── simulation
        │   ├── button_logic.do
        │   ├── score_logic.do
        │   └── testbench
        │       ├── button_logic_tb.vhd
        │       ├── pack_tb_body.vhd
        │       ├── pack_tb_header.vhd
        │       └── score_logic_tb.vhd
        └── src
            ├── lib
            │   ├── auto_control.vhd
            │   ├── ball_logic.vhd
            │   ├── bitmap_generator.vhd
            │   ├── bitmap_memory.vhd
            │   ├── button_logic.vhd
            │   ├── collision_logic.vhd
            │   ├── counter.vhd
            │   ├── font_logic.vhd
            │   ├── game_board.vhd
            │   ├── game_config.vhd
            │   ├── paddle_logic.vhd
            │   ├── pkg.vhd
            │   ├── score_logic.vhd
            │   ├── sound.vhd
            │   ├── vga_graphics.vhd
            │   └── vga_sync.vhd
            ├── mif
            │   ├── game_menu.mif
            │   └── game_over.mif
            └── pong_main.vhd
```

## Building the project from a TCL script  
Ensure you're in the ``EP4CE6_Projects/P12_Pong/Version_x/VHDL/`` directory before running the commands below.  
```
1. mkdir build  
2. cd build
3. quartus_sh -t ../pong_main.tcl
4. quartus pong_main.qpf
```

## What to do when Quartus opens   
- After Quartus opens, click on the ``Processing`` tab  
- Click on ``Start Compilation``  
- After compilation, click on ``Program Device(Open Programmer)``  
- When the Programmer window opens, load the demo project into the FPGA by clicking ``Start``   

## Pinouts  
- Check the ``Location`` column in the image below for the pin mappings used in this project.    
![PP_12](https://github.com/user-attachments/assets/ee5fcd90-15db-4b84-8235-c84e9ae5a0c2)  

## Dual-purpose pins  
Some pins on the Altera EP4CE6 FPGA are dual-purpose i.e. they can be used as regular I/O pins or as programming pins.  
By default, pin 101 (also known as ``nCEO``) is a programming pin. It is routed to the digital-to-analog converter whose  
output feeds the ``Hysnc`` line of the VGA port. This means that we can't use pin 101 unless we set it as a normal I/O pin.  
The images below illustrate how to achieve this.  
### 1. Click on the ``Assignments`` then ``Device``    
![Screenshot (541)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/504f5fbe-3d29-4ada-ae67-1d55cd0d6a2b)  
### 2. Click on ``Device and Pin Options``  
![Screenshot (542)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/e4060aed-3db8-4fc5-b612-175f24c22a6e)  
### 3. Click on ``Dual-Purpose Pins`` and set ``nCEO`` as ``Use as regular I/O``  
![Screenshot (543)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/b380e5d8-d0e3-4c92-b07d-7dc2087eb06e)  

## Video Demo  
- [First Demo](https://drive.google.com/file/d/1IXlxhgczkGYpq6xn5LyXeJhAHxbl6T_r/view?usp=sharing)  
- [I beat the AI](https://drive.google.com/file/d/1HaW-FE-_YOo6Ki-ZLMIf9oCT8mnksFbz/view?usp=sharing)  
- [The AI beat me](https://drive.google.com/file/d/1HirvrqGZgTQL_skde4kLDFoBrUQi2yZQ/view?usp=sharing)    
  
## Tests    
### 1. Testing the ``Button Debounce`` logic with a 2-Channel Digital Storage Oscilloscope
![20240630_124618](https://github.com/user-attachments/assets/93ae3ff8-d681-4c52-8472-368ca29ce7ec)    
![20240630_125431](https://github.com/user-attachments/assets/60c4bf0d-72a1-4d11-982d-2a8d585f6dd7)    
![20240630_124714](https://github.com/user-attachments/assets/5364ac61-3c94-43d8-aca8-21d42eec8170)    
### 2. Simulation and Verification of the ``Button Debounce`` logic  
![Screenshot (593)](https://github.com/user-attachments/assets/00ae062d-da04-4f70-ac43-62da3b28a197)  
![Screenshot (593)_LI](https://github.com/user-attachments/assets/5754ca1e-477a-47f2-adf1-56af04dc2088)  
### 3. Testing 3 kHz sound generation for in-game collisions  
![20240717_124743](https://github.com/user-attachments/assets/5f739067-aae7-484f-896a-1eaeeb6e2829)  
   
## Recommendation(s) / Area(s) of improvement 
1. The text or font aspect of the project can be greatly improved by using ASCII ROMs implemented with block RAMs instead of a purely combinational approach. I used a lot of combinational logic (priority multiplexers) for the digits in the scoreboard. While this wasn't an issue at the end of the day since the design met timing, it won't scale for larger or more complicated projects. With block RAMs, the font ROM's design becomes synchronous and fewer logic elements would be used to implement it. Version 2 drastically improves on Version 1's font logic by eliminating the nested MUXes (priority multiplexers) with counters and fewer MUXes. However, it can be further optimzed to use the same block memory for the "Game menu" and "Game over" texts.  

2. The game can be made more interesting by manipulating the velocity of the ball in other creative ways (i.e. changing the ball's speed and rebound angle after a certain number of collisions).   

## Helpful resource(s)  
- FPGA Prototyping By VHDL Examples (Xilinx Spartan-3 Version) - Pong P. Chu  
- [tinyvga.com](http://tinyvga.com/)
- [Generating Memory Initialization File with MATLAB: Paul_sysu](https://stackoverflow.com/questions/29862161/extracting-memory-initialization-file-mif-from-a-bmp-photo)  

## Simulating the project with Modelsim  
Ensure you're in the ``EP4CE6_Projects/P12_Pong/Version_x/VHDL/simulation/`` directory before proceeding to the next steps.  
The ``.do`` macro files are scripts that contain commands ModelSim uses to compile design files and testbenches. These scripts automate the simulation process by preventing the need to open the ModelSim GUI. For projects with multiple ``.do`` files, the process of executing one script is applicable to the rest. Therefore, the simulation procedure for one script is shown below.  

Procedure for the ``score_logic.do`` script (Same for the other scripts).  
```
mkdir build
cd build
vsim -c -do "do ../score_logic.do; quit"
```
Do not panic if the following output shows up on the command line: ``# ** Failure: Simulation done``. This is a VHDL quirk. The simulation results for the two versions of the Pong project can be viewed on the console or waveform viewer (for button_logic_tb). For the "score logic" simulation, you should see the following command line output.  
```
# ** Note: [INFO]: Right crash
#    Time: 40 ns  Iteration: 0  Instance: /score_logic_tb
# ** Note: Score 1: 01, Score 2: 00
#    Time: 230 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 02, Score 2: 00
#    Time: 450 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 03, Score 2: 00
#    Time: 670 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 04, Score 2: 00
#    Time: 890 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 00
#    Time: 1110 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: [INFO]: Left crash
#    Time: 1950 ns  Iteration: 1  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 01
#    Time: 2150 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 02
#    Time: 2370 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 03
#    Time: 2590 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 04
#    Time: 2810 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 05
#    Time: 3030 ns  Iteration: 4  Instance: /score_logic_tb
```
