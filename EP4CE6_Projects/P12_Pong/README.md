# PONG
![20240716_162535](https://github.com/user-attachments/assets/9ee192a8-05d6-4030-ab9e-0dee5d5aeabc)  

## Description    
This project implements a classic Pong game with an Altera EP4CE6E22C8N Cyclone IV FPGA board, its tactile buttons and buzzer, and a VGA monitor. The game is designed to be single-player i.e. the player plays against an autonomously controlled opposition.  

In the Pong game, there are two paddles and a ball. The player controls the left paddle using two buttons on the FPGA board. One button enables upward movements, while the other moves the paddle in a downward direction. The right paddle is autonomously controlled by digital logic circuits. The reaction time of the right paddle is adjusted every time the left paddle hits the ball. The changes in the right paddle's response prevent it from being unbeatable. The onboard buzzer generates a 3 kHz sound for a short duration every time the ball collides with the following game elements:
1. Left paddle  
2. Right paddle  
3. Upper border of the game board (or screen)
4. Lower border of the game board (or screen)  

The fonts for the scoreboard's digits are implemented using combinational logic (priority muxes and asynchronous ROMs). Another way to implement them is to use the FPGA's block RAMs (this should give better timing results). I wrote some python scripts to generate VHDL code for the Font ROMs by drawing the desired characters (to be displayed on the VGA monitor) using a simple Tkinter interface.  

The "game menu" and "game over" bitmaps (with respective texts of ``PONG`` and ``GAME OVER``) were generated from a simple MATLAB script that performs thresholding and colour inversion on JPEG files (images containing the ``PONG`` and ``GAME OVER`` texts). The MATLAB script also converts the bitmap images to Memory Initialization Files (.mif) whose contents are loaded into the FPGA's block RAMs at compilation time.  

The design is fully constrained and it successfully meets all timing requirements (target frequency of 50 MHz, setup and hold time requirements, etc). The constraints file (pong_main.sdc) can be found in the ``EP4CE6_Projects/P12_Pong/VHDL/`` directory.  

For additional explanations, kindly check the ``README.md`` of the ``MATLAB`` and ``Python`` directories.  

## Tools  
- EP4CE6E22C8N Cyclone IV FPGA development board
- VGA monitor (640 x 480)  
- VGA cable  
- Intel Quartus Prime 20.1
- ModelSim (for simulation)  

## How to use  
- Clone the ``Altera_FPGA_Projects`` repository  
- Open the ``EP4CE6_Projects/P12_Pong/VHDL/`` directory  
- Open the ``pong_main.qpf`` project file  
- Intel Quartus Prime should open after the previous step  
- After Quartus opens, click on the ``Processing`` tab  
- Click on ``Start Compilation``  
- After compilation, click on ``Program Device(Open Programmer)``  
- When the Programmer window opens, load the demo project into the FPGA by clicking ``Start`` 

## Project file structure  
- The **VHDL** design files are located in the **src** and **lib** directories  
- The top-level design is the **pong_main.vhd**  
- The other modules or design files are located in the **lib** directory  
- The **mif** directory contains the ``Memory Initialization Files (.mif)`` generated by MATLAB 

## Pinouts  
- Check the **Location** column in the image below for the pin mappings used in this project.    
![PP_12](https://github.com/user-attachments/assets/ee5fcd90-15db-4b84-8235-c84e9ae5a0c2)  

## Dual-purpose pins  
Some pins on the Altera EP4CE6 FPGA are dual-purpose i.e. they can be used as regular I/O pins or as programming pins.  
By default, pin 101 (also known as ``nCEO``) is a programming pin. It is routed to the digital-to-analog converter whose  
output feeds the ``Hysnc`` line of the VGA port. This means that we can't use pin 101 unless we set it as a normal I/O pin.  
The images below illustrate how to achieve this.  
### 1. Click on the ``Assignments`` then ``Device``    
![Screenshot (541)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/504f5fbe-3d29-4ada-ae67-1d55cd0d6a2b)  
### 2. Click on ``Device and Pin Options``  
![Screenshot (542)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/e4060aed-3db8-4fc5-b612-175f24c22a6e)  
### 3. Click on ``Dual-Purpose Pins`` and set ``nCEO`` as ``Use as regular I/O``  
![Screenshot (543)](https://github.com/MUDAL/Altera_FPGA_Projects/assets/46250887/b380e5d8-d0e3-4c92-b07d-7dc2087eb06e)  

## Video Demo  
- [First Demo](https://drive.google.com/file/d/1IXlxhgczkGYpq6xn5LyXeJhAHxbl6T_r/view?usp=sharing)  
- [I beat the AI](https://drive.google.com/file/d/1HaW-FE-_YOo6Ki-ZLMIf9oCT8mnksFbz/view?usp=sharing)  
- [The AI beat me](https://drive.google.com/file/d/1HirvrqGZgTQL_skde4kLDFoBrUQi2yZQ/view?usp=sharing)    
  
## Tests    
### 1. Testing the ``Button Debounce`` logic with a 2-Channel Digital Storage Oscilloscope
![20240630_124618](https://github.com/user-attachments/assets/93ae3ff8-d681-4c52-8472-368ca29ce7ec)    
![20240630_125431](https://github.com/user-attachments/assets/60c4bf0d-72a1-4d11-982d-2a8d585f6dd7)    
![20240630_124714](https://github.com/user-attachments/assets/5364ac61-3c94-43d8-aca8-21d42eec8170)    
### 2. Simulation and Verification of the ``Button Debounce`` logic  
![Screenshot (593)](https://github.com/user-attachments/assets/00ae062d-da04-4f70-ac43-62da3b28a197)  
![Screenshot (593)_LI](https://github.com/user-attachments/assets/5754ca1e-477a-47f2-adf1-56af04dc2088)  
### 3. Testing 3 kHz sound generation for in-game collisions  
![20240717_124743](https://github.com/user-attachments/assets/5f739067-aae7-484f-896a-1eaeeb6e2829)  

## RTL compilation report
### 1. Resource utilization    
![Screenshot (609)](https://github.com/user-attachments/assets/61675dff-8510-40d9-a36c-3ea4aa5ab0f2)   

### 2. Timing report  
![Screenshot (610)](https://github.com/user-attachments/assets/ccd2067b-9c4b-46b9-ad63-58cc183792fb)  
   
## Simulation report (ModelSim transcript) for the ``score_logic`` module 
### 1. Stimulus generator (from the **score_logic** testbench)  
```
   stimuli: process
      constant DELAY_CLKS: integer := 48;
      ---------------------------------------------------------------
      procedure inject(constant BORDER: in std_logic_vector(1 downto 0);
                       constant CYCLES: in integer) is
      begin
         crash <= BORDER; -- Left or Right
         for i in 0 to CYCLES - 1 loop
            wait until rising_edge(clk);
         end loop;
      end procedure inject;
      ---------------------------------------------------------------
   begin
      wait until rst_n = '1';
      
      report "[INFO]: Right crash";
      inject(RIGHT_CRASH, DELAY_CLKS); 
      
      inject(NO_CRASH, DELAY_CLKS);
      
      report "[INFO]: Left crash";
      inject(LEFT_CRASH, DELAY_CLKS); 
      end_test <= '1';
      wait; 
   end process;
```

### 2. Transcript
```
# ** Note: [INFO]: Right crash
#    Time: 40 ns  Iteration: 0  Instance: /score_logic_tb
# ** Note: Score 1: 01, Score 2: 00
#    Time: 230 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 02, Score 2: 00
#    Time: 450 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 03, Score 2: 00
#    Time: 670 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 04, Score 2: 00
#    Time: 890 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 00
#    Time: 1110 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: [INFO]: Left crash
#    Time: 1950 ns  Iteration: 1  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 01
#    Time: 2150 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 02
#    Time: 2370 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 03
#    Time: 2590 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 04
#    Time: 2810 ns  Iteration: 4  Instance: /score_logic_tb
# ** Note: Score 1: 05, Score 2: 05
#    Time: 3030 ns  Iteration: 4  Instance: /score_logic_tb
```

## Recommendation(s) / Area(s) of improvement 
1. The text or font aspect of the project can be greatly improved by using ASCII ROMs implemented with block RAMs instead of a purely combinational approach. I used a lot of combinational logic (priority multiplexers) for the digits in the scoreboard. While this wasn't an issue at the end of the day since the design met timing, it won't scale for larger or more complicated projects. With block RAMs, the font ROM's design becomes synchronous and fewer logic elements would be used to implement it.

2. The game can be made more interesting by manipulating the velocity of the ball in other creative ways (i.e. changing the ball's speed and rebound angle after a certain number of collisions).   

## Helpful resource(s)  
- FPGA Prototyping By VHDL Examples (Xilinx Spartan-3 Version) - Pong P. Chu  
- [tinyvga.com](http://tinyvga.com/)
- [Generating Memory Initialization File with MATLAB: Paul_sysu](https://stackoverflow.com/questions/29862161/extracting-memory-initialization-file-mif-from-a-bmp-photo)  
